# 数组中重复的数据

公粮. 

题目是这样的: 给定一个整数数组 *a*, 其中 **1 ≤ a[i] ≤ n** (n为数组长度), 其中有些元素出现两次而其他元素出现一次. 找到所有出现两次的元素. 

扩展问题如下: 你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗? 

题目本身很简单, 一个哈希就能解决了. 维护一个哈希集合, 如果元素在哈希集合里面存在, 也就说明该元素出现了两次. 

```
vector<int> findDuplicates(vector<int>& nums) {
    vector<int> vec;
    unordered_set<int> S;
    for (auto n : nums) {
        if (S.count(n)) { vec.push_back(n); }
        S.insert(n);
    }
    return vec;
}
```

这个方法不用说, 时间复杂度 *O(n)*, 空间复杂度 *O(n)* (没有办法啊, 申请一个集合就到 *O(n)* 的复杂度了). 

所以就在想扩展问题该怎么办: 

1. 暴力? 时间是 *O(n^2)*. 两层循环. 太慢了. 
2. 排序? 空间复杂度低的时间复杂度高 (一般到 *O(n^2)* 时间复杂度, 比如**冒泡**, **插入**), 时间复杂度低的空间复杂度高 (比如**堆**, **归并**, **快排**), 特别的可以到 *O(n)* 的计数排序也要额外空间 (这个空间也是 *O(n)* 的... )
3. 分治? 怎么分治? 顺带一提**有递归调用就算额外空间**了... 
4. 贪心? 人家是要求输出所有的结果的... 
5. 数据结构? 额外不允许申请空间, 怎么应用数据结构? 

结果想了半天, 突然发现: **1 ≤ a[i] ≤ n**, 这代表什么呢? 

这代表着**这个数组本身可以作为一个哈希表啊!**

具体做法是这样: 对任意一个元素, 如果**它的值和它的位置不同**, 就**和它的值的位置上的元素交换** (强制让该元素的值和位置相同, 可以看做是做了一次哈希). 

(这里的 *index* 被定义为从 1 开始)

比如: 

i	1	2	3	4
a[i]	1	3	2	2

第一个元素的位置和值相同, 不管. 交换第二个元素和第 (第二个元素值) 个元素 (就是第三个元素啦), 就变成了: 

i	1	2	3	4
a[i]	1	2	3	2

就发现这个数组本身就已经有哈希的属性了. 如果某个位置上的值和位置的 *index* 不同, 就说明这个元素重复了. (如上面的 a[4]. 想想为什么? )

代码就变成了这样: 

```
void swap(vector<int>& V, int p, int q) {
    int tmp = V[p];
    V[p]    = V[q];
    V[q]    = tmp;
}

vector<int> findDuplicates(vector<int>& nums) {
    vector<int> vec;
    for (int i = 0; i < nums.size(); ) {
        if (nums[i] != nums[nums[i]-1]) {
            swap(nums, i, nums[i]-1);
        } else { i++; }
    }
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] != i+1) { vec.push_back(nums[i]); }
    }
    return vec;
}
```
